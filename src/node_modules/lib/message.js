'use strict';

// This file contains definition of StunMessage classes.

const crypto = require('crypto');
const {
  createEncodeStream,
  encode,
  decode,
  encodingLength,
  types: { array },
} = require('binary-data');
const { crc32 } = require('crc');
const constants = require('lib/constants');
const { StunMessagePacket, StunAttributePacket } = require('lib/protocol');
const attributes = require('lib/attributes');

const {
  attributeType,
  messageType,
  kStunFingerprintXorValue,
  kStunFingerprintLength,
  kStunMessageIntegrityLength,
  kStunTransactionIdLength,
  kStunMessageIntegritySize,
  kStunLegacyTransactionIdLength,
} = constants;

const EMPTY_TRANSACTION_ID = Buffer.alloc(kStunTransactionIdLength, 0);

const EMPTY_BUFFER = Buffer.alloc(0);
const EMPTY_MESSAGE_INTEGRITY = Buffer.alloc(kStunMessageIntegritySize, 0);

const toUInt32 = x => x >>> 0; // eslint-disable-line no-bitwise
const MAXINT32 = 0x7fffffff;
const MININT32 = -2147483648;
const isINT32 = v => v <= MAXINT32 && v >= MININT32;

const kMessageType = Symbol('kMessageType');
const kTransactionId = Symbol('kTransctionId');
const kCookie = Symbol('kCookie');
const kAttributes = Symbol('kAttributes');

/**
 * This class implements a STUN message.
 */
class StunMessage {
  /**
   * @class StunMessage
   */
  constructor() {
    this[kMessageType] = 0;
    this[kTransactionId] = EMPTY_TRANSACTION_ID;
    this[kAttributes] = [];
    this[kCookie] = constants.kStunMagicCookie;
  }

  /**
   * Get the type of the message.
   * @returns {number}
   */
  get type() {
    return this[kMessageType];
  }

  /**
   * Get transaction id field.
   * @returns {Buffer}
   */
  get transactionId() {
    return this[kTransactionId];
  }

  /**
   * Get the number of an attributes in current message.
   * @returns {number} The number of an attributes in current message.
   */
  get count() {
    return this[kAttributes].length;
  }

  /**
   * Set message type.
   * @param {number} type - A message type, see constants.
   */
  setType(type) {
    this[kMessageType] = Number(type);
  }

  /**
   * Set `transaction` field for cuurent message.
   * @param {Buffer} transactionId The value of `transaction` field.
   * @returns {boolean} Was the operation successful or not.
   */
  setTransactionID(transactionId) {
    if (!isValidTransactionId(transactionId)) {
      return false;
    }

    this[kTransactionId] = transactionId;
    return true;
  }

  /**
   * Create an instance of StunMessage from Buffer.
   * @param {Buffer} message Encoded to the buffer stun message.
   * @returns {StunMessage} StunMessage instance.
   */
  static from(message) {
    const packet = decode(message, StunMessagePacket);

    const stunMsg = new StunMessage();

    stunMsg.setType(packet.header.type);
    stunMsg.setTransactionID(packet.header.transaction);
    stunMsg[kCookie] = packet.header.cookie;

    stunMsg[kAttributes] = packet.attributes.map(attrPacket =>
      attributes.parse(attrPacket, stunMsg)
    );

    return stunMsg;
  }

  /**
   * Returns true if the message confirms to RFC3489 rather than RFC5389.
   * @returns {boolean} The result of an operation.
   */
  isLegacy() {
    return this[kCookie] !== constants.kStunMagicCookie;
  }

  /**
   * Add an attribute for stun message.
   * @param {number} type Attribute type.
   * @param {*} args Values of an attribute.
   * @returns {StunAttribute} Created attribute.
   */
  addAttribute(type, ...args) {
    const attr = attributes.create(type, ...args);

    attr.setOwner(this);
    this[kAttributes].push(attr);

    return attr;
  }

  /**
   * Return a STUN attribute by it type or undefined.
   * @param {number} type - Attribute type.
   * @returns {StunAttribute|undefined} Instance of StunAttribute or undefined attribute doesn't exist.
   */
  getAttribute(type) {
    return this[kAttributes].find(attr => attr.type === type);
  }

  /**
   * Remove attribute from current message.
   * @param {number} type - Attribute type.
   * @returns {boolean} The result of an operation.
   */
  removeAttribute(type) {
    const index = this[kAttributes].findIndex(attr => attr.type === type);

    if (index === -1) {
      return false;
    }

    switch (index) {
      case 0:
        this[kAttributes].shift();
        break;
      case this[kAttributes].length - 1:
        this[kAttributes].pop();
        break;
      default:
        this[kAttributes].splice(index, 1);
        break;
    }

    return true;
  }

  /**
   * Add MAPPED_ADDRESS attribute.
   * @param {string} address IP address.
   * @param {number} port
   * @returns {StunAddressAttribute}
   */
  addAddress(address, port) {
    return this.addAttribute(attributeType.MAPPED_ADDRESS, address, port);
  }

  /**
   * Add ALTERNATE-SERVER attribute.
   * @param {string} address IP address.
   * @param {number} port
   * @returns {StunAddressAttribute}
   */
  addAlternateServer(address, port) {
    return this.addAttribute(attributeType.ALTERNATE_SERVER, address, port);
  }

  /**
   * Add XOR_MAPPED_ADDRESS attribute.
   * @param {string} address IP address.
   * @param {number} port
   * @returns {StunXorAddressAttribute}
   */
  addXorAddress(address, port) {
    return this.addAttribute(attributeType.XOR_MAPPED_ADDRESS, address, port);
  }

  /**
   * Add USERNAME attribute.
   * @param {string|Buffer} username
   * @returns {StunByteStringAttribute}
   */
  addUsername(username) {
    if (username.length > 513) {
      throw new Error(
        'Username should be less than 513 bytes, see' +
          ' https://tools.ietf.org/html/rfc5389#section-15.3'
      );
    }
    return this.addAttribute(attributeType.USERNAME, username);
  }

  /**
   * Add ERROR-CODE attribute.
   * @param {number} code
   * @param {string} [reason]
   * @returns {StunErrorCodeAttribute}
   */
  addError(code, reason) {
    assertErrorType(this.type);

    // The Class represents
    // the hundreds digit of the error code.  The value MUST be between 3
    // and 6.  The Number represents the error code modulo 100, and its
    // value MUST be between 0 and 99.
    if (code < 300 || code > 699) {
      throw new Error(
        'Error code should between 300 - 699, see https://tools.ietf.org/html/rfc5389#section-15.6'
      );
    }

    if (reason && reason.length > 128) {
      throw new Error(
        'The reason phrase MUST be a UTF-8 encoded sequence of less than 128 characters'
      );
    }

    // Set default error reason for standart error codes.
    if (!reason && constants.errorNames.has(code)) {
      // eslint-disable-next-line no-param-reassign
      reason = constants.errorReason[constants.errorNames.get(code)];
    }

    return this.addAttribute(attributeType.ERROR_CODE, code, reason);
  }

  /**
   * Add REALM attribute.
   * @param {string} realm
   * @returns {StunByteStringAttribute}
   */
  addRealm(realm) {
    assert128string(realm);

    return this.addAttribute(attributeType.REALM, realm);
  }

  /**
   * Add NONCE attribute.
   * @param {string} nonce
   * @returns {StunByteStringAttribute}
   */
  addNonce(nonce) {
    assert128string(nonce);

    return this.addAttribute(attributeType.NONCE, nonce);
  }

  /**
   * Add SOFTWARE attribute.
   * @param {string} software
   * @returns {StunByteStringAttribute}
   */
  addSoftware(software) {
    assert128string(software);

    return this.addAttribute(attributeType.SOFTWARE, software);
  }

  /**
   * Add UNKNOWN-ATTRIBUTES attribute.
   * @param {number[]} attrs List of an unknown attributes.
   * @returns {StunUInt16ListAttribute}
   */
  addUnknownAttributes(attrs) {
    assertErrorType(this.type);

    return this.addAttribute(attributeType.UNKNOWN_ATTRIBUTES, attrs);
  }

  /**
   * Adds a MESSAGE-INTEGRITY attribute that is valid for the current message.
   * @param {string} key Secret hmac key.
   * @returns {boolean} The result of an operation.
   */
  addMessageIntegrity(key) {
    if (!key) {
      return false;
    }

    const attrIntegrity = this.addAttribute(
      attributeType.MESSAGE_INTEGRITY,
      EMPTY_MESSAGE_INTEGRITY
    );
    const msg = this.toBuffer();

    if (msg.length === 0) {
      return false;
    }

    const hmac = crypto.createHmac('sha1', key);
    hmac.update(msg.slice(0, -kStunMessageIntegrityLength));

    return attrIntegrity.setValue(hmac.digest());
  }

  /**
   * Adds a FINGERPRINT attribute that is valid for the current message.
   *
   * @returns {boolean} The result of an operation.
   */
  addFingerprint() {
    const attrFingerprint = this.addAttribute(attributeType.FINGERPRINT, 0);
    const msg = this.toBuffer();

    if (msg.length === 0) {
      return false;
    }

    const crc32buf = msg.slice(0, -kStunFingerprintLength);
    return attrFingerprint.setValue(
      toUInt32(crc32(crc32buf) ^ kStunFingerprintXorValue) // eslint-disable-line no-bitwise
    );
  }

  /**
   * Add PRIORITY attribute.
   * @param {number} priority
   * @returns {StunUInt32Attribute}
   */
  addPriority(priority) {
    if (!Number.isInteger(priority) || !isINT32(priority)) {
      throw new TypeError('The argument should be 32-bit integer.');
    }

    return this.addAttribute(attributeType.PRIORITY, priority);
  }

  /**
   * Add USE-CANDIDATE attribute.
   * @returns {StunByteStringAttribute}
   */
  addUseCandidate() {
    return this.addAttribute(attributeType.USE_CANDIDATE);
  }

  /**
   * Add ICE-CONTROLLED attribute.
   * @param {Buffer} tiebreaker
   * @returns {StunByteStringAttribute}
   */
  addIceControlled(tiebreaker) {
    assertBindingRequest(this.type);

    if (!Buffer.isBuffer(tiebreaker) || tiebreaker.length !== 8) {
      throw new Error(
        'The content of the attribute shoud be a 64-bit unsigned integer'
      );
    }

    return this.addAttribute(attributeType.ICE_CONTROLLED, tiebreaker);
  }

  /**
   * Add ICE-CONTROLLING attribute.
   * @param {Buffer} tiebreaker
   * @returns {StunByteStringAttribute}
   */
  addIceControlling(tiebreaker) {
    assertBindingRequest(this.type);

    if (!Buffer.isBuffer(tiebreaker) || tiebreaker.length !== 8) {
      throw new Error(
        'The content of the attribute shoud be a 64-bit unsigned integer'
      );
    }

    return this.addAttribute(attributeType.ICE_CONTROLLING, tiebreaker);
  }

  /**
   * Convert current message to the Buffer.
   *
   * @private
   * @param {Object} encodeStream Output stream from binary-data.
   * @returns {boolean} The result of an operation.
   */
  write(encodeStream) {
    const attrs = this[kAttributes].map(attr => ({
      type: attr.type,
      value: attr.toBuffer(),
    }));

    const packet = {
      header: {
        type: this.type,
        length: encodingLength(attrs, array(StunAttributePacket, attrs.length)),
        cookie: this[kCookie],
        transaction: this.transactionId,
      },
      attributes: attrs,
    };

    encode(packet, encodeStream, StunMessagePacket);
    return true;
  }

  /**
   * Convert current message to the Buffer.
   * @returns {Buffer} Encoded stun message.
   */
  toBuffer() {
    const encodeStream = createEncodeStream();

    if (this.write(encodeStream)) {
      return encodeStream.slice();
    }

    return EMPTY_BUFFER;
  }
}

/**
 * Iterator over attributes.
 */
StunMessage.prototype[Symbol.iterator] = function* iterator() {
  for (const attribute of this[kAttributes]) {
    yield attribute;
  }
};

/**
 * Check if tranasction id is valid.
 * @param {Buffer} transactionId - `transction` field from a stun message.
 * @returns {boolean} The result of an operation.
 */
function isValidTransactionId(transactionId) {
  return (
    Buffer.isBuffer(transactionId) &&
    (transactionId.length === kStunTransactionIdLength ||
      transactionId.length === kStunLegacyTransactionIdLength)
  );
}

/**
 * Check if argument is a 128 characters string.
 * @param {any} str
 */
function assert128string(str) {
  if (typeof str !== 'string' || str.length > 128) {
    throw new Error(
      'The argument MUST be a UTF-8 encoded sequence of less than 128 characters'
    );
  }
}

/**
 * Check if message type class is ERROR.
 * @param {number} type Message type.
 */
function assertErrorType(type) {
  const isErrorType =
    type === messageType.BINDING_ERROR_RESPONSE ||
    type === messageType.ALLOCATE_ERROR_RESPONSE ||
    type === messageType.REFRESH_ERROR_RESPONSE;

  if (!isErrorType) {
    throw new Error('The attribute should be in ERROR_RESPONSE messages');
  }
}

/**
 * Check if message type is BINDING-REQUEST.
 * @param {number} type Message type.
 */
function assertBindingRequest(type) {
  if (type !== messageType.BINDING_REQUEST) {
    throw new Error('The attribute should present in a Binding request.');
  }
}

module.exports = StunMessage;
